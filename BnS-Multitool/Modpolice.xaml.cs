using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using Newtonsoft.Json;
using Path = System.IO.Path;
using static BnS_Multitool.Functions.FileExtraction;
using static BnS_Multitool.Functions.Crypto;
using BnS_Multitool.Extensions;
using System.Windows.Media;
using System.Collections.ObjectModel;

namespace BnS_Multitool
{
    /// <summary>
    /// Interaction logic for Modpolice.xaml
    /// </summary>
    public partial class Modpolice : Page
    {
        private static string patches_xml = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments) + @"\BnS\patches.xml";
        private static string plugin_path = Path.Combine(SystemConfig.SYS.BNS_DIR, "BNSR", "Binaries", "Win64", "plugins");
        public static string datafile64_sha1 = string.Empty;
        public static string localfile64_sha1 = string.Empty;
        public static DateTime RefreshTime { get; set; } = DateTime.Now;

        public static AvailablePlugins Plugins = null;

        public class PluginInfo
        {
            public string Name { get; set; }
            public string Author { get; set; }
            public string Title { get; set; }
            public string Hash { get; set; }
            public string FullName { get; set; }
            public string MEGA { get; set; }
            public string FilePath { get; set; }
            public long Date { get; set; }
            public string Description { get; set; }
            public Brush FontColor { get; set; }
            public string DateLocal { get; set; }
            public string[] Regions { get; set; }
        }

        public class Hello_Kitty
        {
            public string[] FileNames { get; set; }
            public string DataFile_Hash { get; set; }
            public string LocalFile_Hash { get; set; }
            public string BuildNumber { get; set; }
        }

        private ObservableCollection<PluginInfo> _PluginViewCollection = new ObservableCollection<PluginInfo>();
        public ObservableCollection<PluginInfo> PluginViewCollection { get { return _PluginViewCollection; } }

        public class AvailablePlugins
        {
            public List<PluginInfo> PluginInfo { get; set; }
            public Hello_Kitty HK { get; set; }
        }
        
        public Modpolice()
        {
            InitializeComponent();
        }

        public enum HK_State
        {
            Not_Installed,
            Installed,
            Outdated,
            Installed_ButBuildMismatch,
            Error,
            Update_Available,
            Missing_datafile
        }

        // Retrieves a list of available plugins
        // List is generated by me, files are checked against their mega links on server and updated every 15 minutes
        public static async Task<AvailablePlugins> RetrieveOnlinePlugins()
        {
            try
            {
                if (DateTime.Now <= RefreshTime) return Plugins;
                RefreshTime = DateTime.Now.AddMinutes(1);
                using (GZipWebClient client = new GZipWebClient())
                {
                    string response = await client.DownloadStringTaskAsync(string.Format("{0}plugins/plugins.json", Globals.MAIN_SERVER_ADDR));
                    if (string.IsNullOrEmpty(response)) return null;
                    return JsonConvert.DeserializeObject<AvailablePlugins>(response);
                }
            } catch (Exception ex)
            {
                return null;
            }
        }

        private async void Page_Loaded(object sender, RoutedEventArgs e)
        {
            MainGrid.Visibility = Visibility.Visible;
            HKUpdater.Visibility = Visibility.Hidden;
            PluginInfoGrid.Visibility = Visibility.Hidden;

            // Only show HK Updater button for NA / EU
            //HKUpdaterBtn.Visibility = (Globals.BnS_Region)ACCOUNT_CONFIG.ACCOUNTS.REGION != Globals.BnS_Region.TW ? Visibility.Visible : Visibility.Hidden;

            _PluginViewCollection.Clear();
            Plugins = await RetrieveOnlinePlugins();
            if(Plugins == null)
            {
                new ErrorPrompt("Failed to retrieve plugins from server, could be DNS issue.").ShowDialog();
                Logger.log.Error("Plugins::Page_Loaded::Failed to retrieve online plugins");
                return;
            }

            foreach (var plugin in Plugins.PluginInfo)
            {
                // Check if our region is not allowed to see this
                if (plugin.Regions != null && plugin.Regions.Count() > 0 && plugin.Regions.Contains(ACCOUNT_CONFIG.ACCOUNTS.REGION.ToString())) continue;
                // Skip over if plugin entry is binloader and region is set to TW
                if (plugin.Name == "binloader" && ((Globals.BnS_Region)ACCOUNT_CONFIG.ACCOUNTS.REGION == Globals.BnS_Region.TW)) continue;

                // Do not display plugins with an invalid filename, this is for when I add new plugins.
                if (plugin.FullName.IsNullOrEmpty()) continue;

                // Special handling as HK and Bin Loader are tied to the hip.
                if (plugin.Name == "binloader")
                {
                    var datafile = Path.GetFullPath(Path.Combine(plugin_path, "datafile64.bin"));
                    var localfile = Path.GetFullPath(Path.Combine(plugin_path, "localfile64.bin"));

                    if (File.Exists(datafile) && File.Exists(localfile) && File.Exists(Path.Combine(plugin_path, "binloader.dll")))
                    {
                        if (Process.GetProcessesByName("BNSR").Count() == 0)
                        {
                            if (datafile64_sha1.IsNullOrEmpty())
                                datafile64_sha1 = SHA1_File(datafile);
                            if (localfile64_sha1.IsNullOrEmpty())
                                localfile64_sha1 = SHA1_File(localfile);

                            if (datafile64_sha1 == Plugins.HK.DataFile_Hash.ToLower() && localfile64_sha1 == Plugins.HK.LocalFile_Hash.ToLower())
                                plugin.FontColor = Brushes.CornflowerBlue;
                            else
                                plugin.FontColor = Brushes.Yellow;
                        }
                        else
                            plugin.FontColor = Brushes.CornflowerBlue;
                    }
                    else if (File.Exists(Path.Combine(plugin_path, "binloader.dll")))
                        plugin.FontColor = Brushes.OrangeRed;
                    else
                        plugin.FontColor = Brushes.White;
                }
                else
                {
                    var pluginP = Path.GetFullPath(Path.Combine(SystemConfig.SYS.BNS_DIR, plugin.FilePath));
                    if (File.Exists(pluginP))
                    {
                        if (Process.GetProcessesByName("BNSR").Count() == 0)
                        {
                            if (SHA1_File(pluginP) == plugin.Hash.ToLower())
                                plugin.FontColor = Brushes.CornflowerBlue;
                            else
                                plugin.FontColor = Brushes.Yellow;
                        }
                        else
                            plugin.FontColor = Brushes.CornflowerBlue;
                    }
                    else
                        plugin.FontColor = Brushes.White;
                }

                _PluginViewCollection.Add(new PluginInfo
                {
                    Name = plugin.Name,
                    Author = plugin.Author,
                    Title = plugin.Title,
                    Hash = plugin.Hash,
                    FontColor = plugin.FontColor,
                    FilePath = plugin.FilePath,
                    FullName = plugin.FullName,
                    Date = plugin.Date,
                    Description = plugin.Description,
                    DateLocal = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc).AddSeconds(plugin.Date).ToLocalTime().ToString("g")
                });
            }
        }

        private void openBinLocation(object sender, RoutedEventArgs e) =>
            Process.Start(Path.Combine(SystemConfig.SYS.BNS_DIR, "BNSR", "Binaries", "Win64"));

        private void PluginSelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if ((sender as ListView).SelectedIndex == -1) return;
            var pluginInfo = (sender as ListView).SelectedItem as PluginInfo;
            if (pluginInfo == null) return;

            var pluginPath = Path.GetFullPath(Path.Combine(SystemConfig.SYS.BNS_DIR, pluginInfo.FilePath));
            if(File.Exists(pluginPath))
            {
                InstallOrUpdate_BTN.Content = "Update";
                Remove_BTN.Visibility = Visibility.Visible;
            } else
            {
                InstallOrUpdate_BTN.Content = "Install";
                Remove_BTN.Visibility = Visibility.Hidden;
            }

            AuthorLabel.Content = string.Format("Author: {0}", pluginInfo.Author);
            PluginDescription.Text = pluginInfo.Description;
            PluginInfoGrid.Visibility = Visibility.Visible;
        }

        private void RemovePluginClick(object sender, RoutedEventArgs e)
        {
            if (AvailablePluginsView.SelectedIndex == -1) return;
            var pluginInfo = (AvailablePluginsView.SelectedItem as PluginInfo);
            if (pluginInfo == null) return;

            var pluginPath = Path.GetFullPath(Path.Combine(SystemConfig.SYS.BNS_DIR, pluginInfo.FilePath));
            if(File.Exists(pluginPath))
                File.Delete(pluginPath);

            // Special handling for binloader because its bundled with HK
            if(pluginInfo.Name == "binloader")
            {
                var datafile = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(pluginPath), "datafile64.bin"));
                var localfile = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(pluginPath), "localfile64.bin"));
                var inifile = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(pluginPath), "binloader.ini"));

                if(File.Exists(datafile)) File.Delete(datafile);
                if(File.Exists(localfile)) File.Delete(localfile);
                if(File.Exists(inifile)) File.Delete(inifile);

                SystemConfig.SYS.HK_Installed = false;
                SystemConfig.Save();
            } else if (pluginInfo.Name == "bnspatch")
            {
                if(File.Exists(patches_xml))
                    File.Delete(patches_xml);
            }

            pluginInfo.FontColor = Brushes.White;
            PluginInfoGrid.Visibility = Visibility.Hidden;
            AvailablePluginsView.SelectedIndex = -1;
            AvailablePluginsView.Items.Refresh();
        }

        public static async Task<HK_State> HKCheck()
        {
            string binloader = Path.GetFullPath(Path.Combine(SystemConfig.SYS.BNS_DIR, "BNSR", "Binaries", "Win64", "plugins", "binloader.dll"));
            string datafile = Path.GetFullPath(Path.Combine(SystemConfig.SYS.BNS_DIR, "BNSR", "Binaries", "Win64", "plugins", "datafile64.bin"));
            string localfile = Path.GetFullPath(Path.Combine(SystemConfig.SYS.BNS_DIR, "BNSR", "Binaries", "Win64", "plugins", "localfile64.bin"));

            if (DateTime.Now >= RefreshTime)
            {
                datafile64_sha1 = SHA1_File(datafile);
                localfile64_sha1 = SHA1_File(localfile);
                Plugins = await RetrieveOnlinePlugins();
            }
            // Additional Check
            if (datafile64_sha1.IsNullOrEmpty())
                datafile64_sha1 = SHA1_File(datafile);
            if (localfile64_sha1.IsNullOrEmpty())
                localfile64_sha1 = SHA1_File(localfile);

            // Check if datafile64.bin is missing but binloader is present
            if (File.Exists(binloader) && !File.Exists(datafile))
                return HK_State.Missing_datafile;

            // Check if there is an update available based off datafile
            if (SystemConfig.SYS.HK_Installed && !datafile64_sha1.IsNullOrEmpty() && datafile64_sha1 != Plugins.HK.DataFile_Hash.ToLower())
                return HK_State.Update_Available;

            // Check if there is an update available based off localfile
            if (SystemConfig.SYS.HK_Installed && !localfile64_sha1.IsNullOrEmpty() && localfile64_sha1 != Plugins.HK.LocalFile_Hash.ToLower())
                return HK_State.Update_Available;

            if (!File.Exists(binloader)) return HK_State.Not_Installed; // Binloader is not present so no need to check the rest

            var iniFile = Directory.GetFiles(SystemConfig.SYS.BNS_DIR, "VersionInfo_*.ini").FirstOrDefault();
            string localVersion = string.Empty;
            if (!iniFile.IsNullOrEmpty())
            {
                IniHandler VersionInfo_BnS = new IniHandler(iniFile);
                localVersion = VersionInfo_BnS.Read("VersionInfo", "GlobalVersion");
            }
            if (localVersion.IsNullOrEmpty()) return HK_State.Error; // Someones game is fucked if this file can't be found and loaded
            if (!File.Exists(datafile) || !File.Exists(localfile)) return HK_State.Outdated;

            if (localVersion == Plugins.HK.BuildNumber)
            {
                if (datafile64_sha1 == Plugins.HK.DataFile_Hash.ToLower() && localfile64_sha1 == Plugins.HK.LocalFile_Hash.ToLower()) return HK_State.Installed;
                if (datafile64_sha1 == Plugins.HK.DataFile_Hash.ToLower() && localfile64_sha1 != Plugins.HK.LocalFile_Hash.ToLower()) return HK_State.Installed;
            } else
            {
                if (datafile64_sha1 == Plugins.HK.DataFile_Hash.ToLower() && localfile64_sha1 == Plugins.HK.LocalFile_Hash.ToLower()) return HK_State.Installed_ButBuildMismatch;
                if (datafile64_sha1 == Plugins.HK.DataFile_Hash.ToLower() && localfile64_sha1 != Plugins.HK.LocalFile_Hash.ToLower()) return HK_State.Installed_ButBuildMismatch;
            }

            return HK_State.Outdated;
        }

        private ProgressControl _progressControl;

        private async void InstallOrUpdateClick(object sender, RoutedEventArgs e)
        {
            if (AvailablePluginsView.SelectedIndex == -1) return;
            var pluginInfo = (AvailablePluginsView.SelectedItem as PluginInfo);
            if (pluginInfo == null) return;

            _progressControl = new ProgressControl();
            ProgressGrid.Visibility = Visibility.Visible;
            MainGrid.Visibility = Visibility.Collapsed;
            ProgressPanel.Children.Add(_progressControl);
            ProgressControl.updateProgressLabel(string.Format("Installing: {0}", pluginInfo.Title));

            try
            {
                if (await InstallPlugin(pluginInfo))
                {
                    ProgressControl.updateProgressLabel(string.Format("Installed {0}", pluginInfo.Title));
                    await Task.Delay(200);

                    // Check if bnspatch
                    if (pluginInfo.Name == "bnspatch")
                    {
                        ProgressControl.updateProgressLabel("Checking if patches.xml exists..");
                        await Task.Delay(100);

                        if (!File.Exists(patches_xml))
                        {
                            File.WriteAllText(patches_xml, Properties.Resources.patches);
                            ProgressControl.updateProgressLabel("Installed patches.xml");
                            await Task.Delay(100);
                        }
                    }

                    if (pluginInfo.Name == "binloader")
                    {
                        ProgressControl.updateProgressLabel("Installing Hello Kitty");
                        if (!await InstallHelloKitty())
                            throw new Exception("Failed to download and install bins");
                        ProgressControl.updateProgressLabel("Hello kitty bins downloaded");
                        await Task.Delay(300);
                    }

                    ProgressControl.updateProgressLabel("Validating installation");
                    await Task.Delay(100);
                    var pluginPath = Path.GetFullPath(Path.Combine(SystemConfig.SYS.BNS_DIR, pluginInfo.FilePath));
                    if (File.Exists(pluginPath))
                    {
                        if (SHA1_File(pluginPath) == pluginInfo.Hash.ToLower())
                        {
                            pluginInfo.FontColor = Brushes.CornflowerBlue;
                            InstallOrUpdate_BTN.Content = "Update";
                            Remove_BTN.Visibility = Visibility.Visible;
                        }
                        else
                        {
                            pluginInfo.FontColor = Brushes.OrangeRed;
                            throw new Exception(string.Format("Local hash does not match online hash {0}", Path.GetFileName(pluginPath)));
                        }
                    }
                    else
                        throw new Exception(string.Format("{0} was not found", pluginPath));
                }
                else
                    throw new Exception("Failed to download and unzip plugin");
            }
            catch (Exception ex)
            {
                Logger.log.Error("Plugins::InstallOrUpdateClick\nType: {0}\n{1}\n{2}", ex.GetType().Name, ex.ToString(), ex.StackTrace);
                ProgressControl.errorSadPeepo(Visibility.Visible);
                ProgressControl.updateProgressLabel("There was an error, check logs");
                await Task.Delay(TimeSpan.FromSeconds(5));
            }
            finally
            {
                AvailablePluginsView.Items.Refresh();
                ProgressGrid.Visibility = Visibility.Hidden;
                MainGrid.Visibility = Visibility.Visible;
                ProgressPanel.Children.Clear();
                _progressControl = null;
            }
        }

        private static async Task<long> RemoteFileSize(string url)
        {
            var req = System.Net.HttpWebRequest.Create(new Uri(url));
            req.Method = "HEAD";

            try
            {
                using (var response = await req.GetResponseAsync())
                    return response.ContentLength;
            } catch (Exception ex)
            {
                Logger.log.Error("Error Request: {0}\n{1}\n{2}", url, ex.Message, ex.StackTrace);
                return 0L;
            }
        }

        private static async Task<bool> DownloadRemoteFile(string url, string path)
        {
            var contentLength = 0L;
            bool retryDownload = false;
            try
            {
            TryFileDownload:
                contentLength = await RemoteFileSize(url);

                // Make sure the content length is greater than 0
                if (contentLength == 0)
                    throw new Exception("Could not retrieve content length for " + url);

                // Incase we're retrying a download get rid of the old one
                if(File.Exists(path))
                    File.Delete(path);

                using(System.Net.WebClient client = new System.Net.WebClient())
                {
                    client.DownloadProgressChanged += new System.Net.DownloadProgressChangedEventHandler(Client_DownloadProgressChanged);
                    downloadFile = Path.GetFileName(path);
                    await client.DownloadFileTaskAsync(new Uri(url), path);
                }

                FileInfo fInfo = new FileInfo(path);
                if(!fInfo.Exists && !retryDownload)
                {
                    retryDownload = true;
                    goto TryFileDownload;
                } else if (!fInfo.Exists && retryDownload)
                    throw new Exception(string.Format("Failed to download: {0}", Path.GetFileName(path)));
                else
                {
                    if (fInfo.Length != contentLength && !retryDownload)
                    {
                        retryDownload = true;
                        goto TryFileDownload;
                    }
                    else if (fInfo.Length != contentLength && retryDownload)
                        throw new Exception(string.Format("Failed to download: {0}, file length does not match. Is windows defender on?", Path.GetFileName(path)));
                }
            }
            catch (Exception ex)
            {
                Logger.log.Error("{0}\n{1}", ex.Message, ex.StackTrace);
                return false;
            }
            return true;
        }

        public static async Task<bool> InstallHelloKitty()
        {
            var datafile = Path.GetFullPath(Path.Combine(plugin_path, "datafile64.bin"));
            var localfile = Path.GetFullPath(Path.Combine(plugin_path, "localfile64.bin"));
            string webUrl;
            long contentLength = 0L;
            bool downloadResult = false;
            try
            {
                //IniHandler hIni = new IniHandler(Directory.GetFiles(SystemConfig.SYS.BNS_DIR, "VersionInfo_*.ini").FirstOrDefault());
                // Update datafile if it needs it.
                if (File.Exists(datafile))
                {
                    datafile64_sha1 = SHA1_File(datafile);
                    if (datafile64_sha1 == Plugins.HK.DataFile_Hash.ToLower()) goto CheckLocalFile;
                }

                var fInfo = new FileInfo(Path.GetFullPath(Path.Combine("modpolice", Plugins.HK.FileNames.First(x => x.Contains("datafile")))));
                webUrl = string.Format("{0}plugins/{1}", Globals.MAIN_SERVER_ADDR, Plugins.HK.FileNames.First(x => x.Contains("datafile")));
                contentLength = await RemoteFileSize(webUrl);
                if (!fInfo.Exists || (contentLength > 0 && fInfo.Length != contentLength))
                {
                    downloadResult = await DownloadRemoteFile(webUrl, Path.GetFullPath(Path.Combine("modpolice", Plugins.HK.FileNames.First(x => x.Contains("datafile")))));
                    if (!downloadResult)
                        throw new Exception("Failed to download HK because of file download error");
                }

                // Create some slack if the file is locked or something...
                if (IsFileLocked(Path.GetFullPath(Path.Combine("modpolice", Plugins.HK.FileNames.First(x => x.Contains("datafile"))))))
                    await Task.Delay(200);

                if(ExtractArchiveLZMA(Path.GetFullPath(Path.Combine("modpolice", Plugins.HK.FileNames.First(x => x.Contains("datafile")))), plugin_path))
                    datafile64_sha1 = SHA1_File(datafile);
                else throw new Exception("Failed to extract");

                // Update localfile if it needs it
                CheckLocalFile:
                if (File.Exists(localfile))
                {
                    localfile64_sha1 = SHA1_File(localfile);
                    if (localfile64_sha1 == Plugins.HK.LocalFile_Hash.ToLower()) goto Finished;
                }

                var localFileName = Plugins.HK.FileNames.First(x => x.Contains("localfile"));
                webUrl = string.Format("{0}plugins/{1}", Globals.MAIN_SERVER_ADDR, localFileName);
                fInfo = new FileInfo(Path.Combine("modpolice", localFileName));
                contentLength = await RemoteFileSize(webUrl);
                if (!fInfo.Exists || (contentLength > 0 && fInfo.Length != contentLength))
                {
                    downloadResult = await DownloadRemoteFile(webUrl, Path.Combine("modpolice", localFileName));
                    if (!downloadResult)
                        throw new Exception("Failed to download HK because of file download error");
                }

                // Create some slack if the file is locked or something...
                if (IsFileLocked(Path.GetFullPath(Path.Combine("modpolice", Plugins.HK.FileNames.First(x => x.Contains("localfile"))))))
                    await Task.Delay(200);

                if (ExtractArchiveLZMA(Path.GetFullPath(Path.Combine("modpolice", Plugins.HK.FileNames.First(x => x.Contains("localfile")))), plugin_path))
                    localfile64_sha1 = SHA1_File(localfile);

                else throw new Exception("Failed to extract");

            Finished:
                if(!SystemConfig.SYS.HK_Installed)
                {
                    SystemConfig.SYS.HK_Installed = true;
                    SystemConfig.Save();
                }
                return true;

            } catch (Exception ex)
            {
                Logger.log.Error("Plugins::InstallHelloKitty\nType: {0}\n{1}\n{2}", ex.GetType().Name, ex.ToString(), ex.StackTrace);
                return false;
            }
        }

        private static string downloadFile = "";
        private static void Client_DownloadProgressChanged(object sender, System.Net.DownloadProgressChangedEventArgs e)
        {
            ProgressControl.updateProgressLabel(string.Format("Downloading {0} {1}%", downloadFile, e.ProgressPercentage));
        }

        public static async Task<bool> InstallPlugin(PluginInfo plugin)
        {
            var pluginPath = Path.GetFullPath(Path.Combine(SystemConfig.SYS.BNS_DIR, plugin.FilePath));
            
            // Check if the plugin currently exists
            if(File.Exists(pluginPath))
            {
                if (SHA1_File(pluginPath) == plugin.Hash) return true; // Plugin exists and matches online version
                File.Delete(pluginPath); // Delete the plugin in preperation for new installation
            }
            try
            {
                string url = string.Format("{0}plugins/{1}", Globals.MAIN_SERVER_ADDR, plugin.FullName);
                bool downloadResult = await DownloadRemoteFile(url, Path.GetFullPath(Path.Combine("modpolice", plugin.FullName)));
                if (!downloadResult)
                    throw new Exception("Failed to download plugin");

                ExtractZipFileToDirectory(Path.GetFullPath(Path.Combine("modpolice", plugin.FullName)), SystemConfig.SYS.BNS_DIR, true);
            } catch (Exception ex)
            {
                Logger.log.Error("Plugins::InstallPlugin\nType: {0}\n{1}\n{2}", ex.GetType().Name, ex.ToString(), ex.StackTrace);
                return false;
            }

            return true;
        }
    }
}