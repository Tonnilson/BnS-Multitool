using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using Newtonsoft.Json;
using Path = System.IO.Path;
using static BnS_Multitool.Functions.FileExtraction;
using static BnS_Multitool.Functions.Crypto;
using BnS_Multitool.Extensions;
using System.Windows.Media;
using System.Collections.ObjectModel;

namespace BnS_Multitool
{
    /// <summary>
    /// Interaction logic for Modpolice.xaml
    /// </summary>
    public partial class Modpolice : Page
    {
        private static string patches_xml = Path.Combine(SystemConfig.SYS.BNSPATCH_DIRECTORY, "patches.xml");
        private static string plugin_path = Path.Combine(SystemConfig.SYS.BNS_DIR, "BNSR", "Binaries", "Win64", "plugins");
        public static string datafile64_sha1 = string.Empty;
        public static string localfile64_sha1 = string.Empty;
        private bool init = false;
        public static DateTime RefreshTime { get; set; } = DateTime.Now;

        public static AvailablePlugins Plugins = null;

        public class PluginInfo
        {
            public string Name { get; set; }
            public string Author { get; set; }
            public string Title { get; set; }
            public string Hash { get; set; }
            public string FullName { get; set; }
            public string MEGA { get; set; }
            public string FilePath { get; set; }
            public long Date { get; set; }
            public string Description { get; set; }
            public Brush FontColor { get; set; }
            public string DateLocal { get; set; }
            public string[] Regions { get; set; }
        }

        public class Hello_Kitty
        {
            public string[] FileNames { get; set; }
            public string DataFile_Hash { get; set; }
            public string LocalFile_Hash { get; set; }
            public string BuildNumber { get; set; }
        }

        private ObservableCollection<PluginInfo> _PluginViewCollection = new ObservableCollection<PluginInfo>();
        public ObservableCollection<PluginInfo> PluginViewCollection { get { return _PluginViewCollection; } }

        public class AvailablePlugins
        {
            public List<PluginInfo> PluginInfo { get; set; }
            public Hello_Kitty HK { get; set; }
            public Hello_Kitty HK_TW { get; set; }
        }
        
        public Modpolice()
        {
            InitializeComponent();
        }

        public enum HK_State
        {
            Not_Installed,
            Installed,
            Outdated,
            Installed_ButBuildMismatch,
            Error,
            Update_Available,
            Missing_datafile
        }

        // Retrieves a list of available plugins
        // List is generated by me, files are checked against their mega links on server and updated every 15 minutes
        public static async Task<AvailablePlugins> RetrieveOnlinePlugins()
        {
            try
            {
                if (DateTime.Now <= RefreshTime) return Plugins;
                RefreshTime = DateTime.Now.AddMinutes(1);
                using (GZipWebClient client = new GZipWebClient())
                {
                    string response = await client.DownloadStringTaskAsync(string.Format("{0}plugins/plugins_v2.json", Globals.MAIN_SERVER_ADDR));
                    if (string.IsNullOrEmpty(response)) return null;
                    return JsonConvert.DeserializeObject<AvailablePlugins>(response);
                }
            } catch (Exception ex)
            {
                return null;
            }
        }

        private async void Page_Loaded(object sender, RoutedEventArgs e)
        {
            MainGrid.Visibility = Visibility.Visible;
            PluginInfoGrid.Visibility = Visibility.Hidden;

            if(!init)
            {
                AutoPluginUpdates.IsChecked = SystemConfig.SYS.AUTO_UPDATE_PLUGINS;
                init = true;
            }

            // Only show HK Updater button for NA / EU
            //HKUpdaterBtn.Visibility = (Globals.BnS_Region)ACCOUNT_CONFIG.ACCOUNTS.REGION != Globals.BnS_Region.TW ? Visibility.Visible : Visibility.Hidden;

            _PluginViewCollection.Clear();
            Plugins = await RetrieveOnlinePlugins();
            if(Plugins == null)
            {
                new ErrorPrompt("Failed to retrieve plugins from server, could be DNS issue.").ShowDialog();
                Logger.log.Error("Plugins::Page_Loaded::Failed to retrieve online plugins");
                return;
            }

            foreach (var plugin in Plugins.PluginInfo)
            {
                // Check if our region is not allowed to see this
                if (plugin.Regions != null && plugin.Regions.Count() > 0 && plugin.Regions.Contains(ACCOUNT_CONFIG.ACCOUNTS.REGION.ToString())) continue;
                // Skip over if plugin entry is binloader and region is set to TW
                

                // Do not display plugins with an invalid filename, this is for when I add new plugins.
                if (plugin.FullName.IsNullOrEmpty()) continue;

                // Special handling as HK and Bin Loader are tied to the hip.
                if (plugin.Name == "binloader")
                {
                    var datafile = Path.GetFullPath(Path.Combine(plugin_path, "datafile64.bin"));
                    var localfile = Path.GetFullPath(Path.Combine(plugin_path, "localfile64.bin"));

                    if (File.Exists(datafile) && File.Exists(localfile) && File.Exists(Path.Combine(plugin_path, "binloader.dll")))
                    {
                        if (datafile64_sha1.IsNullOrEmpty())
                            datafile64_sha1 = CRC32_File(datafile);
                        if (localfile64_sha1.IsNullOrEmpty())
                            localfile64_sha1 = CRC32_File(localfile);

                        Hello_Kitty HK_Info = null;
                        if (((Globals.BnS_Region)ACCOUNT_CONFIG.ACCOUNTS.REGION == Globals.BnS_Region.TW))
                            HK_Info = Plugins.HK_TW;
                        else
                            HK_Info = Plugins.HK;

                        if (datafile64_sha1 == HK_Info.DataFile_Hash && localfile64_sha1 == HK_Info.LocalFile_Hash)
                            plugin.FontColor = Brushes.CornflowerBlue;
                        else
                            plugin.FontColor = Brushes.Yellow;
                    }
                    else if (File.Exists(Path.Combine(plugin_path, "binloader.dll")))
                        plugin.FontColor = Brushes.OrangeRed;
                    else
                        plugin.FontColor = Brushes.White;
                }
                else
                {
                    var pluginP = Path.GetFullPath(Path.Combine(SystemConfig.SYS.BNS_DIR, plugin.FilePath));
                    if (File.Exists(pluginP))
                    {
                        if (CRC32_File(pluginP) == plugin.Hash)
                            plugin.FontColor = Brushes.CornflowerBlue;
                        else
                            plugin.FontColor = Brushes.Yellow;
                    }
                    else
                        plugin.FontColor = Brushes.White;
                }

                _PluginViewCollection.Add(new PluginInfo
                {
                    Name = plugin.Name,
                    Author = plugin.Author,
                    Title = plugin.Title,
                    Hash = plugin.Hash,
                    FontColor = plugin.FontColor,
                    FilePath = plugin.FilePath,
                    FullName = plugin.FullName,
                    Date = plugin.Date,
                    Description = plugin.Description,
                    DateLocal = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc).AddSeconds(plugin.Date).ToLocalTime().ToString("g")
                });
            }
        }

        private void openBinLocation(object sender, RoutedEventArgs e) =>
            Process.Start(Path.Combine(SystemConfig.SYS.BNS_DIR, "BNSR", "Binaries", "Win64"));

        private void PluginSelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if ((sender as ListView).SelectedIndex == -1) return;
            var pluginInfo = (sender as ListView).SelectedItem as PluginInfo;
            if (pluginInfo == null) return;

            var pluginPath = Path.GetFullPath(Path.Combine(SystemConfig.SYS.BNS_DIR, pluginInfo.FilePath));
            if(File.Exists(pluginPath))
            {
                InstallOrUpdate_BTN.Content = "Update";
                Remove_BTN.Visibility = Visibility.Visible;
            } else
            {
                InstallOrUpdate_BTN.Content = "Install";
                Remove_BTN.Visibility = Visibility.Hidden;
            }

            AuthorLabel.Content = string.Format("Author: {0}", pluginInfo.Author);
            PluginDescription.Text = pluginInfo.Description;
            PluginInfoGrid.Visibility = Visibility.Visible;
        }

        private void RemovePluginClick(object sender, RoutedEventArgs e)
        {
            if (AvailablePluginsView.SelectedIndex == -1) return;
            var pluginInfo = (AvailablePluginsView.SelectedItem as PluginInfo);
            if (pluginInfo == null) return;

            var pluginPath = Path.GetFullPath(Path.Combine(SystemConfig.SYS.BNS_DIR, pluginInfo.FilePath));
            if(File.Exists(pluginPath))
                File.Delete(pluginPath);

            // Special handling for binloader because its bundled with HK
            if(pluginInfo.Name == "binloader")
            {
                var datafile = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(pluginPath), "datafile64.bin"));
                var localfile = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(pluginPath), "localfile64.bin"));
                var inifile = Path.GetFullPath(Path.Combine(Path.GetDirectoryName(pluginPath), "binloader.ini"));

                if(File.Exists(datafile)) File.Delete(datafile);
                if(File.Exists(localfile)) File.Delete(localfile);
                if(File.Exists(inifile)) File.Delete(inifile);

                SystemConfig.SYS.HK_Installed = false;
                SystemConfig.Save();
            } else if (pluginInfo.Name == "bnspatch")
            {
                if(File.Exists(patches_xml))
                    File.Delete(patches_xml);
            }

            pluginInfo.FontColor = Brushes.White;
            PluginInfoGrid.Visibility = Visibility.Hidden;
            AvailablePluginsView.SelectedIndex = -1;
            AvailablePluginsView.Items.Refresh();
        }

        private ProgressControl _progressControl;

        private async void InstallOrUpdateClick(object sender, RoutedEventArgs e)
        {
            if (AvailablePluginsView.SelectedIndex == -1) return;
            var pluginInfo = (AvailablePluginsView.SelectedItem as PluginInfo);
            if (pluginInfo == null) return;

            _progressControl = new ProgressControl();
            ProgressGrid.Visibility = Visibility.Visible;
            MainGrid.Visibility = Visibility.Collapsed;
            ProgressPanel.Children.Add(_progressControl);
            ProgressControl.updateProgressLabel(string.Format("Installing: {0}", pluginInfo.Title));

            try
            {
                if (await InstallPlugin(pluginInfo))
                {
                    ProgressControl.updateProgressLabel(string.Format("Installed {0}", pluginInfo.Title));
                    await Task.Delay(200);

                    // Check if bnspatch
                    if (pluginInfo.Name == "bnspatch")
                    {
                        ProgressControl.updateProgressLabel("Checking if patches.xml exists..");
                        await Task.Delay(100);

                        if (!File.Exists(patches_xml))
                        {
                            SystemConfig.SYS.PATCH_424 = true;
                            SystemConfig.Save();
                            File.WriteAllText(patches_xml, Properties.Resources.patches);
                            ProgressControl.updateProgressLabel("Installed patches.xml");
                            await Task.Delay(100);
                        }
                    }

                    ProgressControl.updateProgressLabel("Validating installation");
                    await Task.Delay(100);
                    var pluginPath = Path.GetFullPath(Path.Combine(SystemConfig.SYS.BNS_DIR, pluginInfo.FilePath));
                    if (File.Exists(pluginPath))
                    {
                        if (CRC32_File(pluginPath) == pluginInfo.Hash)
                        {
                            pluginInfo.FontColor = Brushes.CornflowerBlue;
                            InstallOrUpdate_BTN.Content = "Update";
                            Remove_BTN.Visibility = Visibility.Visible;
                        }
                        else
                        {
                            pluginInfo.FontColor = Brushes.OrangeRed;
                            throw new Exception(string.Format("Local hash does not match online hash {0}", Path.GetFileName(pluginPath)));
                        }
                    }
                    else
                        throw new Exception(string.Format("{0} was not found", pluginPath));
                }
                else
                    throw new Exception("Failed to download and unzip plugin");
            }
            catch (Exception ex)
            {
                Logger.log.Error("Plugins::InstallOrUpdateClick\nType: {0}\n{1}\n{2}", ex.GetType().Name, ex.ToString(), ex.StackTrace);
                ProgressControl.errorSadPeepo(Visibility.Visible);
                ProgressControl.updateProgressLabel("There was an error, check logs");
                await Task.Delay(TimeSpan.FromSeconds(5));
            }
            finally
            {
                AvailablePluginsView.Items.Refresh();
                ProgressGrid.Visibility = Visibility.Hidden;
                MainGrid.Visibility = Visibility.Visible;
                ProgressPanel.Children.Clear();
                _progressControl = null;
            }
        }

        private static async Task<long> RemoteFileSize(string url)
        {
            var req = System.Net.HttpWebRequest.Create(new Uri(url));
            req.Method = "HEAD";

            try
            {
                using (var response = await req.GetResponseAsync())
                    return response.ContentLength;
            } catch (Exception ex)
            {
                Logger.log.Error("Error Request: {0}\n{1}\n{2}", url, ex.Message, ex.StackTrace);
                return 0L;
            }
        }

        private static async Task<bool> DownloadRemoteFile(string url, string path)
        {
            var contentLength = 0L;
            bool retryDownload = false;
            try
            {
            TryFileDownload:
                contentLength = await RemoteFileSize(url);

                // Make sure the content length is greater than 0
                if (contentLength == 0)
                    throw new Exception("Could not retrieve content length for " + url);

                // Incase we're retrying a download get rid of the old one
                if(File.Exists(path))
                    File.Delete(path);

                using(System.Net.WebClient client = new System.Net.WebClient())
                {
                    client.DownloadProgressChanged += new System.Net.DownloadProgressChangedEventHandler(Client_DownloadProgressChanged);
                    downloadFile = Path.GetFileName(path);
                    await client.DownloadFileTaskAsync(new Uri(url), path);
                }

                FileInfo fInfo = new FileInfo(path);
                if(!fInfo.Exists && !retryDownload)
                {
                    retryDownload = true;
                    goto TryFileDownload;
                } else if (!fInfo.Exists && retryDownload)
                    throw new Exception(string.Format("Failed to download: {0}", Path.GetFileName(path)));
                else
                {
                    if (fInfo.Length != contentLength && !retryDownload)
                    {
                        retryDownload = true;
                        goto TryFileDownload;
                    }
                    else if (fInfo.Length != contentLength && retryDownload)
                        throw new Exception(string.Format("Failed to download: {0}, file length does not match. Is windows defender on?", Path.GetFileName(path)));
                }
            }
            catch (Exception ex)
            {
                Logger.log.Error("{0}\n{1}", ex.Message, ex.StackTrace);
                return false;
            }
            return true;
        }

        private static string downloadFile = "";
        private static void Client_DownloadProgressChanged(object sender, System.Net.DownloadProgressChangedEventArgs e)
        {
            ProgressControl.updateProgressLabel(string.Format("Downloading {0} {1}%", downloadFile, e.ProgressPercentage));
        }

        public static async Task<bool> InstallPlugin(PluginInfo plugin)
        {
            var pluginPath = Path.GetFullPath(Path.Combine(SystemConfig.SYS.BNS_DIR, plugin.FilePath));
            
            // Check if the plugin currently exists
            if(File.Exists(pluginPath))
            {
                if (CRC32_File(pluginPath) == plugin.Hash) return true; // Plugin exists and matches online version
                File.Delete(pluginPath); // Delete the plugin in preperation for new installation
            }

            // This should be remove a few months after update push and SYS.HK_Installed should be phased out entirely.
            if(plugin.Name == "hellokitty" && SystemConfig.SYS.HK_Installed)
            {
                if (File.Exists(Path.Combine(SystemConfig.SYS.BNS_DIR, "BNSR", "Binaries", "Win64", "plugins", "binloader.dll")))
                    File.Delete(Path.Combine(SystemConfig.SYS.BNS_DIR, "BNSR", "Binaries", "Win64", "plugins", "binloader.dll"));

                if (File.Exists(Path.Combine(SystemConfig.SYS.BNS_DIR, "BNSR", "Binaries", "Win64", "plugins", "binloader.ini")))
                    File.Delete(Path.Combine(SystemConfig.SYS.BNS_DIR, "BNSR", "Binaries", "Win64", "plugins", "binloader.ini"));

                if (File.Exists(Path.Combine(SystemConfig.SYS.BNS_DIR, "BNSR", "Binaries", "Win64", "plugins", "localfile64.bin")))
                    File.Delete(Path.Combine(SystemConfig.SYS.BNS_DIR, "BNSR", "Binaries", "Win64", "plugins", "localfile64.bin"));

                if (File.Exists(Path.Combine(SystemConfig.SYS.BNS_DIR, "BNSR", "Binaries", "Win64", "plugins", "datafile64.bin")))
                    File.Delete(Path.Combine(SystemConfig.SYS.BNS_DIR, "BNSR", "Binaries", "Win64", "plugins", "datafile64.bin"));

                if ((Globals.BnS_Region)ACCOUNT_CONFIG.ACCOUNTS.REGION == Globals.BnS_Region.TW)
                {
                    if (File.Exists(Path.Combine(SystemConfig.SYS.BNSPATCH_DIRECTORY, "patches", "hellokitty_tw-FixQuest.xml")))
                        File.Delete(Path.Combine(SystemConfig.SYS.BNSPATCH_DIRECTORY, "patches", "hellokitty_tw-FixQuest.xml"));
                }

                SystemConfig.SYS.HK_Installed = false;
                SystemConfig.Save();
            }
            try
            {
                string url = string.Format("{0}plugins/{1}", Globals.MAIN_SERVER_ADDR, plugin.FullName);
                bool downloadResult = await DownloadRemoteFile(url, Path.GetFullPath(Path.Combine("modpolice", plugin.FullName)));
                if (!downloadResult)
                    throw new Exception("Failed to download plugin");

                ExtractZipFileToDirectory(Path.GetFullPath(Path.Combine("modpolice", plugin.FullName)), SystemConfig.SYS.BNS_DIR, true);
            } catch (Exception ex)
            {
                Logger.log.Error("Plugins::InstallPlugin\nType: {0}\n{1}\n{2}", ex.GetType().Name, ex.ToString(), ex.StackTrace);
                return false;
            }

            return true;
        }

        private void AutoPluginClicked(object sender, RoutedEventArgs e)
        {
            if (!init) return;
            var option = (sender as CheckBox);
            SystemConfig.SYS.AUTO_UPDATE_PLUGINS = (bool)option.IsChecked;
            SystemConfig.Save();
        }
    }
}